---
title: "**Sequencing 16S rRNA gene fragments using the PacBio SMRT DNA sequencing system**"
bibliography: references.bib
output:
  pdf_document:
    includes:
      in_header: header.tex
csl: peerj.csl
fontsize: 11pt
geometry: margin=1.0in
---


```{r knitr_settings, eval=TRUE, echo=FALSE, cache=FALSE}
opts_chunk$set("tidy" = TRUE)
opts_chunk$set("echo" = FALSE)
opts_chunk$set("eval" = TRUE)
opts_chunk$set("warning" = FALSE)
opts_chunk$set("cache" = FALSE)

inline_hook <- function(x){
	print(x)
	if(is.numeric(x)){
		if(abs(x - round(x)) < .Machine$double.eps^0.5){
			paste(format(x,big.mark=',', digits=0, scientific=FALSE))
		} else {
			paste(format(x,big.mark=',', digits=1, nsmall=1, scientific=FALSE))
		}

	} else {
    	paste(x)      
	}
}
knitr::knit_hooks$set(inline=inline_hook)

regions <- c("V1V3", "V1V5", "V1V6", "V1V9", "V3V5", "V4")
clrs <- rainbow(length(regions))
pretty_region <- c("V1V3"="V1-V3", "V1V5"="V1-V5", "V1V6"="V1-V6", "V1V9"="V1-V9", "V3V5"="V3-V5", "V4"="V4")
names(clrs) <- regions

mock_error <- read.table(file="data/process/mock.error.report")
mock_error_nochim <- mock_error[mock_error$numparents==1,]
mock_error_good <- mock_error_nochim[mock_error_nochim$error <= 0.10,]
```

\vspace{35mm}

**Running title:** 16S rRNA genes sequencing with PacBio

\vspace{15mm}

**Authors:** Patrick D. Schloss^1#^, Sarah L. Westcott^1^, Matthew L. Jenior^1^,
and Sarah K. Highlander^2^

\vspace{40mm}

$\dagger$ To whom correspondence should be addressed: pschloss@umich.edu

1\. Department of Microbiology and Immunology, 1500 W. Medical Center, University of Michigan, Ann Arbor, MI 48109

2\. Genomic Medicine, J. Craig Venter Institute, 4120 Capricorn Lane, La Jolla, CA 92307


\newpage
\linenumbers


## Abstract [ Revise ]
Over the past 10 years, microbial ecologists have largely abandoned sequencing
16S rRNA genes by the Sanger sequencing method and have instead adopted highly
parallelized sequencing platforms. These new platforms, such as 454 and
Illumina's MiSeq, have allowed researchers to obtain millions of high quality,
but short sequences. These platforms have allowed researchers to significantly
improve the design of their experiments. The tradeoff has been the decline in
the number of full-length reference sequences that are deposited into databases.
To overcome this problem, we tested the ability of the PacBio Single Molecule,
Real-Time (SMRT) DNA sequencing platform to generate sequence reads from the 16S
rRNA gene. We generated sequencing data from the V4, V3-V5, V1-V3, V1-V6, and
V1-V9 variable regions from within the 16S rRNA gene from a synthetic mock
community and natural samples collected from human feces, mouse feces, and soil.
The synthetic mock community allowed us to assess the actual sequencing error
rate and how that error rate changed when different curation methods were
applied. We developed a simple method based on sequence characteristics and
quality scores to reduce the observed error rate for the V1-V9 region from 2.16%
to 0.32%. Unfortunately, this error rate was still 16-times higher than the
error rate that has been observed for the shorter reads generated by 454 and
Illumina's MiSeq sequencing platforms. Although the longer reads frequently
provided better classification, the wider adoption of this approach for 16S rRNA
gene sequencing is likely limited by its high sequencing error and low yield of
sequencing data relative to the other available platforms.


***Keywords:*** Microbial ecology, bioinformatics, sequencing error



## Introduction [ Revise ]
Advances in sequencing technologies over the past 10 years have introduced
considerable advances to the field of microbial ecology. Clone-based Sanger
sequencing of the 16S rRNA gene has largely been replaced by various platforms
produced by 454/Roche {e.g. Sogin, 2006 #1510}, Illumina
{e.g. Gloor, 2010 #2611}, and IonTorrent {e.g. Junemann, 2012 #2630}. It was
once common to sequence fewer than 100 16S rRNA gene sequences from several
samples using the Sanger approach {e.g. McCaig, 1999 #592}. Now it is common to
generate thousands of sequences from each of several hundred samples
{The Human Microbiome Consortium, 2012 #2617}. The advance in throughput has
come at the cost of read length. Sanger sequencing regularly generated 800 nt
per read and because the DNA was cloned, it was possible to obtain multiple
reads per fragment to yield a full-length sequence from a representative single
molecule. At approximately $8 (US) per sequencing read, most
researchers have effectively decided that full-length sequences are not worth
the increased cost relative to the cost of more recently developed approaches.
There is still a clear need to generate high-throughput full-length sequence
reads that are of sufficient quality that they can be used as references for
analyses based on obtaining short sequence reads.

Historically, all sequencing platforms were created to primarily perform genome
sequencing. When sequencing a genome, it is assumed that the same base of DNA
will be sequenced multiple times and the consensus of multiple sequence reads is
used to generate contigs. Thus, although an individual base call may have a high
error rate, the consensus sequence will have a low error rate. To sequence the
16S rRNA gene researchers use conserved primers to amplify a sub-region from
within the gene that is isolated from many organisms. Because the fragments
are not cloned, it is not possible to obtain high sequence coverage from the
same DNA molecule using these platforms. Thus, to reduce sequencing error rates
it has become imperative to develop stringent sequence curation and denoising
algorithms {Kozich, 2013 #2719; Schloss, 2011 #2466}. There has been a tradeoff
between read length, number of reads per sample, and the error rate. For
instance, we recently demonstrated that using the Illumina MiSeq and the 454
Titanium platforms the raw error rate varies between 1 and 2% {Kozich, 2013
#2719; Schloss, 2011 #2466}. Yet, it was possible to obtain error rates below
0.02% by adopting various denoising algorithms. However, the resulting fragments
were only 250-nt long. In the case of 454 Titanium, extending the length of the
fragment introduces length-based errors and in the case of the Illumina MiSeq,
increasing the length of the fragment reduces the overlap between the read pairs
reducing the ability of each read to mutually reduce the sequencing error.
Inadequate denoising of sequencing reads can have many negative effects
including limited ability to identify chimeras {Haas, 2011 #2404;Edgar, 2011 #2406}
and inflation of alpha- and beta-diversity metrics
{Huse, 2010 #2034; Kunin, 2010 #2259; Kozich, 2013 #2719; Schloss, 2011 #2466}.
Although MiSeq and 454 enjoy widespread use in the field, the MiSeq
platform is emerging as the leader because of the ability to sequence 15-20
million fragments that can be distributed across hundreds of samples for less
than $5000 (US).

As these sequencing platforms have grown in popularity, there has been a decline
in the number of full-length 16S rRNA genes being deposited into GenBank that
could serve as references. This is particularly frustrating since the
technologies have significantly improved our ability to detect and identify
novel populations for which we lack full-length reference sequences. A related
problem is the perceived limitation that the short reads generated by the 454
and Illumina platforms cannot be reliably classified to the genus or
species level. Previous investigators have utilized simulations to
demonstrate that increased read lengths usually increase the accuracy and
sensitivity of classification against reference databases
{Liu, 2008 #2188;Werner, 2012 #2474;Wang, 2007 #1809}. There is
clearly a need to develop sequencing technologies that will allow researchers to
generate high quality full-length 16S rRNA gene sequences in a high throughput
manner.

New advances in single molecule sequencing technologies, such as the platform
produced by Pacific Biosciences (PacBio), offer the opportunity to once again
obtain full-length sequence reads with a high depth of coverage from a large
number of samples. To this point, the PacBio Single Molecule, Real-Time (SMRT)
DNA Sequencing System has received limited application in the microbial ecology
research domain {Mosher, 2014 #3376; Fichot, 2013 #3453; Mosher, 2013 #3454}.
The SMRT system ligates hairpin adapters (i.e. SMRTbells) to the ends of
double-stranded DNA. Although the DNA molecule is linear, it is effectively
circularized allowing the sequencing polymerase to process around the molecule
multiple times {Au, 2012 #3455}. According to Pacific Biosciences the platform
is able to generate median read lengths longer than 8 kb with the P4-C2
chemistry; however, the single pass error rate is approximately 15%. Given the
circular nature of the DNA fragment, the full read length can be used to cover
the DNA fragment multiple times resulting in a reduced error rate. Therefore,
one should be able to obtain multiple coverage of the full 16S rRNA gene at a
reduced error rate.

Despite the opportunity to potentially generate high-quality full-length
sequences, the Pacific Biosciences platform has not been widely adopted for
sequencing 16S rRNA genes {Fichot, 2013 #3453; Mosher, 2014 #3376; Mosher, 2014 #3376}.
Previous studies utilizing the technology have removed reads with mismatched
primers and barcodes, ambiguous base  calls, and low quality scores {Fichot, 2013 #3453}.
Others have utilized the platform without describing the bioinformatic pipeline
that was utilized {Mosher, 2014 #3376; Mosher, 2014 #3376}. Regardless of the
curation methods, the error rates associated with sequencing the 16S rRNA gene
on the platform have never been reported. In the current study, we assessed the
quality of data generated by the Pacific Biosciences sequencer and whether it
could fill the need for generating high-quality, full-length sequence data. We
hypothesized that by modulating the 16S rRNA gene fragment length we could alter
the read depth and obtain reads longer than are currently available by the 454
and Illumina platforms but with the same quality. To test this hypothesis, we
developed a sequence curation pipeline that was optimized by reducing the
sequencing error rate of a mock bacterial community with known composition. The
resulting pipeline was then applied to 16S rRNA gene fragments that were
isolated from soil and human and mouse feces.


## Materials and Methods
***Community DNA.*** We utilized genomic DNA isolated from four communities.
These same DNA extracts were previously used to develop an Illumina MiSeq-based
sequencing strategy {Kozich, 2013 #2719}.  Briefly, we used a “Mock Community”
composed of genomic DNA from 21 bacterial strains: *Acinetobacter baumannii*
ATCC 17978, *Actinomyces odontolyticus* ATCC 17982, *Bacillus cereus* ATCC
10987, *Bacteroides vulgatus* ATCC 8482, *Clostridium beijerinckii* ATCC 51743,
*Deinococcus radiodurans* ATCC 13939, *Enterococcus faecalis* ATCC 47077,
*Escherichia coli* ATCC 70096, *Helicobacter pylori* ATCC 700392, *Lactobacillus
gasseri* ATCC 33323, *Listeria monocytogenes* ATCC BAA-679, *Neisseria
meningitidis* ATCC BAA-335, *Porphyromonas gingivalis* ATCC 33277,
*Propionibacterium acnes* DSM 16379, *Pseudomonas aeruginosa* ATCC 47085,
*Rhodobacter sphaeroides* ATCC 17023, *Staphylococcus aureus* ATCC BAA-1718,
*Staphylococcus epidermidis* ATCC 12228, *Streptococcus agalactiae* ATCC
BAA-611, *Streptococcus mutans* ATCC 700610, *Streptococcus pneumoniae* ATCC
BAA-334. The mock community DNA is available through BEI resources (v3.1,
HM-278D). Genomic DNAs from the three other communities were obtained using the
MO BIO PowerSoil DNA extraction kit. The human and mouse fecal samples were
obtained using protocols that were reviewed and approved by the University
Committee on Use and Care of Animals (Protocol #PRO00004877) and the
Institutional Review Board at the University of Michigan (Protocol
#HUM00057066). The human stool donor provided informed consent.

***Library generation and sequencing.*** [ Revise ]
The DNAs were each amplified in triplicate using barcoded primers targeting the
V4, V1-V3, V3-V5, V1-V5, V1-V6, and V1-V9 variable regions (Table 1). The
primers were synthesized so that the 5’ end of the forward and reverse primers
were each tagged with a 5-nt barcode sequence to allow multiplexing of samples
within a single sequencing run. Methods describing PCR, amplicon cleanup, and
pooling were described previously {Kozich, 2013 #2719}. The SMRTbell adapters
were ligated onto  the PCR products and the libraries were sequenced by Pacific
Biosciences using the P6-C24 chemistry on a PacBio RS II SMRT DNA Sequencing
System.


***Data analysis.***  [ Revise ]
All sequencing data were curated using mothur {Schloss, 2009 #1816} and analyzed
using the R programming language {R Core Team, 2014 #3456}. The raw data can be
obtained from the Sequence Read Archive at NCBI under accession SRP051686, which
are associated with BioProject PRJNA271568. Several specific features were
incorporated into mothur to facilitate the analysis of PacBio  sequence data.
First, because non-ambiguous base calls are assigned to Phred quality scores of
zero, the consensus fastq files were parsed so that scores of zero were
interpreted as corresponding to an ambiguous base call (i.e. N) in the
fastq.info command using the pacbio=T option. Second, because the consensus
sequence can be generated in the forward and reverse complement orientations, a
checkorient option was added to the trim.seqs command in order to identify the
proper orientation. These features were incorporated into mothur v.1.30. Because
chimeric molecules can be generated during PCR and would artificially inflate
the sequencing error, it was necessary to remove these data prior to assessing
the error rate. Because we knew the true sequences for the strains in the mock
community we could calculate all possible chimeras between strains in the mock
community (*in silico* chimeras). If a sequence read was 3 or more nucleotides
more similar to an *in silico* chimera than it was to a non-chimeric reference
sequence, it was classified as a chimera and removed from further consideration.
Identification of *in silico* chimeras and calculation of sequencing error rates
was performed using the seq.error command in mothur {Schloss, 2011 #2466}. *De
novo* chimera detection was also performed on the mock and other sequence data
using the abundance-based algorithm implemented in UCHIME {Edgar, 2011 #2406}.
Sequences sequences were aligned against a SILVA-based reference alignment
{Pruesse, 2007 #1735} using a profile-based aligner {Schloss, 2009 #1825} and
were classified against the SILVA {Pruesse, 2007 #1735}, RDP {Cole, 2014 #3460},
and greengenes {Werner, 2012 #2474} reference taxonomies  using a naive Bayesian
classifier {Wang, 2007 #1809}. Sequences were assigned to operational taxonomic
units using the average neighbor clustering algorithm with a 3% distance
threshold {Schloss, 2011 #3156}.  Detailed methods including this paper as an R
markdown file are available as a public online repository
(http://github.com/SchlossLab/ Schloss_PacBio16S_PeerJ_2015).


## Results and Discussion

```{r error_profile}
mutations <- c("AA", "AT", "AG", "AC", "TA", "TT", "TG", "TC", "GA", "GT", "GG", "GC", "CA", "CT", "CG", "CC", "Ai", "Ti", "Gi", "Ci", "dA", "dT", "dG", "dC")

mutation_table <- mock_error_good[, which(colnames(mock_error_good)%in%mutations)]
mutation_count <- apply(mutation_table, 2, sum)

mutation_total <- sum(mutation_count)
matches <- sum(mutation_count[c("AA", "TT", "GG", "CC")])
mis_matches <- mutation_total - matches
init_error_rate <- 100 * mis_matches / mutation_total		#0.6514488


#substitutions
substitutions <- mutations[grep("[ATGC].", mutations)]
substitutions <- substitutions[grep(".[ATGC]", substitutions)]
substitutions <- substitutions[! substitutions %in% c("AA", "TT", "GG", "CC")]
substitution_counts <- mutation_count[substitutions]
substitution_total <- sum(substitution_counts)
substitution_bias <- substitution_counts / substitution_total

reference <- gsub(".(.)", "\\1", names(substitution_bias))
# aggregate(substitution_bias, by=list(reference), mean)
#
# Group.1          x
# 1       A 0.10192188
# 2       C 0.05944286
# 3       G 0.07434043
# 4       T 0.09762816

substitution_rate <- 100 * substitution_total / mis_matches

# [1] 50.90346


#deletions
deletion_counts <- mutation_count[grep("d.", mutations)]
deletion_total <- sum(deletion_counts)
deletion_bias <- 100 * deletion_counts / deletion_total

#dA        dT        dG        dC
#24.25770 17.99132 39.44415 18.30683

deletion_rate <- 100 * deletion_total / mis_matches

#[1] 17.93361

#insertions
insertion_counts <- mutation_count[grep(".i", mutations)]
insertion_total <- sum(insertion_counts)
insertion_bias <- 100 * insertion_counts / insertion_total

#Ai        Ti        Gi        Ci
#23.13509 19.63951 30.05906 27.16633

insertion_rate <- 100 * insertion_total / mis_matches

#[1] 31.16293



# Need to connect error types with the quality scores
error_quality <- read.table(file="data/process/mock.quality.report", header=T, row.names=1)

#get quantiles
matches <- rep(as.numeric(rownames(error_quality)), error_quality$matches)
m.quant <- quantile(matches, prob=c(0.025, 0.25, 0.5, 0.75, 0.975))
m.94 <- 100 * sum(matches >= 94)/length(matches)
# [1] 80.52649

subs <- rep(as.numeric(rownames(error_quality)), error_quality$substitutions)
s.quant <- quantile(subs, prob=c(0.025, 0.25, 0.5, 0.75, 0.975))
s.94 <- 100 * sum(subs >= 94)/length(subs)
# [1] 79.96451

ins <- rep(as.numeric(rownames(error_quality)), error_quality$insertions)
i.quant <- quantile(ins, prob=c(0.025, 0.25, 0.5, 0.75, 0.975))
i.94 <- 100 * sum(ins >= 94)/length(ins)
# [1] 80.35283


## Basic error correction analysis
get_raw_error <- function(region){
	region_data <- mock_error_good[mock_error_good$region == region,]
	return(100*sum(region_data$mismatches)/sum(region_data$total))
}

raw_rates <- sapply(regions, get_raw_error)

get_basic_kept <- function(region){
	region_data <- mock_error_good[mock_error_good$region == region,]
	100 * sum(region_data$good_coords & region_data$good_homop)/nrow(region_data)
}

basic_kept <- sapply(regions, get_basic_kept)

get_basic_error <- function(region){
	region_data <- mock_error_good[mock_error_good$region == region & mock_error_good$good_coords & mock_error_good$good_homop,]
	return(100*sum(region_data$mismatches)/sum(region_data$total))
}

basic_rates <- sapply(regions, get_basic_error)

mock_error_basic <- mock_error_good[mock_error_good$good_coords & mock_error_good$good_homop,]
basic_n <- aggregate(mock_error_basic$error, by=list(mock_error_basic$region), length)$x
names(basic_n) <- names(basic_rates)

basic_error_rate <- 100 * sum(mock_error_basic$mismatches) / sum(mock_error_basic$total)		#[1] 0.6448736
```

***The PacBio error profile and a basic sequence curation procedure.***
To build a sequence curation pipeline, we first needed to characterize the error
rate associated with sequencing the 16S rRNA gene. We observed an average
sequencing error rate of `r format(100*init_error_rate, digits=2, nsmall=2)`%. Insertions, deletions, and substitutions
accounted for `r format(insertion_rate, digits=3, nsmall=1)`,
`r format(deletion_rate, digits=3, nsmall=1)`, and `r format(substitution_rate, digits=3, nsmall=1)`% of the errors, respectively. The substitution errors were equally
likely and all four bases
were equally likely to cause insertion errors. Interestingly, guanines
(`r format(deletion_bias["dG"], digits=3, nsmall=1)`%) and adenines
(`r format(deletion_bias["dA"], digits=3, nsmall=1)`%) were more likely to be deleted
than cytosines (`r format(deletion_bias["dC"], digits=3, nsmall=1)`%) or thymidines
(`r format(deletion_bias["dT"], digits=2, nsmall=1)`%). The PacBio quality values varied between
`r paste(range(c(matches, subs, ins)), collapse=' and ')`. Surprisingly, the percentage of base calls that had the maximum quality value did not vary among correct base calls (`r format(m.94, digits=3, nsmall=1)`%), substitutions (`r format(s.94, digits=3, nsmall=1)`%), and insertions (`r format(i.94, digits=3, nsmall=1)`%). Although the individual base quality scores could not be used to screen sequence quality, we observed a strong correlation between our observed error rate and the predicted error rate as calculated by the PacBio software (Pearson's R: `r format(cor(mock_error_good$error, mock_error_good$pred_error), digits=2, nsmall=2)`; Figure 1A).

We established a simple curation procedure by culling any sequence that had a
string of the same base repeated more than 8 times  or did not start and end at
the expected alignment coordinates for that region of the 16S rRNA gene. This
reduced the experiment-wide error rate from `r format(init_error_rate, digits=3, nsmall=2)` to
`r format(basic_error_rate, digits=2, nsmall=2)`%. This basic procedure
resulted in the removal of between
`r format(min(100-basic_kept), digits=3, nsmall=1)`
(`r pretty_region[names(which.min(100-basic_kept))]`) and
`r format(max(100-basic_kept), digits=3, nsmall=1)`
(`r pretty_region[names(which.max(100-basic_kept))]`)% of the reads (Table 2). Although
the percentage of reads removed increased with the length of the fragment, there
was no obvious relationship between fragment length and error rate (Figure 2).


```{r barcode_primer_analysis}
mock_error_basic$pbdiffs <- mock_error_basic$fbdiffs + mock_error_basic$rbdiffs + mock_error_basic$fpdiffs + mock_error_basic$rpdiffs

#This is for the Figure 2B plot...
pb_overall <- aggregate(mock_error_basic$error, by=list(mock_error_basic$pbdiffs), function(x){c(mean=mean(100*x))})


# want to get the error rate and fraction of sequences for each region with a
# threshold of mismatches or fewer

pb_by_region_mm <- aggregate(mock_error_basic$error, by=list(mock_error_basic$pbdiffs, mock_error_basic$region), function(x){c(mean=mean(100*x), nseqs=length(x))})

aggregate_pb_data <- function(region){
	pb_region <- pb_by_region_mm[pb_by_region_mm$Group.2 == region,]

	product <- pb_region$x[,"mean"] * pb_region$x[,"nseqs"]
	pb_region_nseqs <- cumsum(pb_region$x[,"nseqs"])
	pb_region_error <- cumsum(product) / pb_region_nseqs
	pb_region_frac <- pb_region_nseqs / sum(pb_region$x[,"nseqs"])
	c(error=pb_region_error, fraction=pb_region_frac)
}

pb_data <- sapply(regions, aggregate_pb_data)

pb_error <- pb_data[grep("error", rownames(pb_data)),]
rownames(pb_error) <- 0:6

pb_fraction <- pb_data[grep("fraction", rownames(pb_data)),]
rownames(pb_fraction) <- 0:6

pb_error_reduction_0 <- 100 * (1 - pb_error["0",]/basic_rates)
pb_error_reduction_1 <- 100 * (1 - pb_error["1",]/basic_rates)

pb_nseqs_reduction_0 <- 100 * (1 - pb_fraction["0",])
pb_nseqs_reduction_1 <- 100 * (1 - pb_fraction["1",])
```


```{r coverage_analysis}
#This is for the Figure 2C plot...
coverage_overall_agg <- aggregate(100 * mock_error_basic$error, by=list(mock_error_basic$coverage), mean)
coverage_overall <- coverage_overall_agg$x
names(coverage_overall) <- coverage_overall_agg$Group.1
coverage_overall <- coverage_overall[as.character(3:40)]


# need to get the error rate for coverage values between 3 and 40 for each region

error_by_coverage <- function(region){
	coverage_region <- mock_error_basic[mock_error_basic$region == region,]
	coverage_error_agg <- aggregate(100 * coverage_region$error, by=list(coverage_region$coverage), mean)
	coverage_error <- coverage_error_agg[coverage_error_agg$Group.1 <= 40,"x"]
	names(coverage_error) <- coverage_error_agg[coverage_error_agg$Group.1 <= 40,"Group.1"]
	coverage_error
}

coverage_error <- sapply(regions, error_by_coverage)
#seems to plateau right around 10


error_at_below_coverage_cutoff <- function(region, cutoff=10){
	region_data <- mock_error_basic[mock_error_basic$region == region,]

	deep <- region_data$coverage >= 10
	coverage_data <- region_data[deep,]

	error <- 100 * sum(coverage_data$mismatches)/sum(coverage_data$total)
	frac_kept <- nrow(coverage_data) / nrow(region_data)
	c(error=error, fraction=frac_kept)
}

coverage_data <- sapply(regions, error_at_below_coverage_cutoff)

coverage_error <- coverage_data["error",]
coverage_fraction <- coverage_data["fraction",]

coverage_error_reduction <- 100 * (1 - coverage_error/basic_rates)
coverage_nseqs_reduction <- 100 * (1 - coverage_fraction)
```


```{r predicted_error_analysis }
#This is for the Figure 2D plot...
pred_overall <- aggregate(100 * mock_error_basic$error, by=list(round(mock_error_basic$pred_error, 3)), mean)

error_at_above_pred_error_cutoff <- function(region, threshold=0.999){
	region_data <- mock_error_basic[mock_error_basic$region == region,]

	above_threshold <- region_data[region_data$pred_error >= threshold,]

	c(error=100*sum(above_threshold$mismatches)/sum(above_threshold$total), nseqs=nrow(above_threshold)/nrow(region_data))
}

pred_error_data <- sapply(regions, error_at_above_pred_error_cutoff, threshold=0.999)

pred_error_reduction <- 100 * (1 - pred_error_data["error",]/basic_rates)
pred_nseqs_reduction <- 100 * (1 - pred_error_data["nseqs",])
```



```{r oligos_coverage_analysis}
get_oligos_coverage <- function(region){
	region_data <- mock_error_basic[mock_error_basic$region == region,]

	good0 <- region_data$pbdiffs <= 0 & region_data$coverage >= 10
	region_data_good0 <- region_data[good0,]

	good1 <- region_data$pbdiffs <= 1 & region_data$coverage >= 10
	region_data_good1 <- region_data[good1,]

	c(	100*mean(region_data_good0[,"error"]), nrow(region_data_good0)/nrow(region_data),
		100*mean(region_data_good1[,"error"]), nrow(region_data_good1)/nrow(region_data))
}

oligos_coverage_error <- matrix(unlist(lapply(regions, get_oligos_coverage)), ncol=4, byrow=T)
rownames(oligos_coverage_error) <- regions
colnames(oligos_coverage_error) <- c("0.10.error", "0.10.frac", "1.10.error", "1.10.frac")

#     0.10.error 0.10.frac 1.10.error 1.10.frac
#V1V3  0.4515344 0.5898447  0.4632910 0.7968639
#V1V5  0.4187311 0.5557715  0.4270938 0.7384810
#V1V6  0.4399351 0.5410259  0.4460726 0.7167325
#V1V9  0.4317629 0.4444776  0.4420337 0.5752849
#V3V5  0.6421004 0.6854427  0.6555240 0.8102832
#V4    0.6825316 0.5512332  0.7023460 0.8245533

oligos_coverage_error_reduction <- 100 * (1 - oligos_coverage_error[,"1.10.error"]/basic_rates)
oligos_coverage_nseqs_reduction <- 100 * (1 - oligos_coverage_error[,"1.10.frac"])
```


```{r oligosQScoreAnalysis}
get_oligos_pred_error <- function(region){
	region_data <- mock_error_basic[mock_error_basic$region == region,]

	good0 <- region_data$pbdiffs <= 0 & region_data$pred_error >= 0.999
	region_data_good0 <- region_data[good0,]

	good1 <- region_data$pbdiffs <= 1 & region_data$pred_error >= 0.999
	region_data_good1 <- region_data[good1,]

	c(	100 * mean(region_data_good0[,"error"]), nrow(region_data_good0)/nrow(region_data),
		100 * mean(region_data_good0[,"error"]), nrow(region_data_good0)/nrow(region_data) )
}

oligos_pred_error <- matrix(unlist(lapply(regions, get_oligos_pred_error)), ncol=4, byrow=T)
rownames(oligos_pred_error) <- regions
colnames(oligos_pred_error) <- c("0.999.error", "0.999.frac", "1.999.error", "1.999.frac")

#     0.999.error 0.999.frac 1.999.error 1.999.frac
#V1V3   0.2806049  0.4749822   0.2806049  0.4749822
#V1V5   0.2177965  0.4266279   0.2177965  0.4266279
#V1V6   0.2168503  0.4296550   0.2168503  0.4296550
#V1V9   0.2177073  0.3438720   0.2177073  0.3438720
#V3V5   0.2229757  0.5131411   0.2229757  0.5131411
#V4     0.3485654  0.3961328   0.3485654  0.3961328

oligos_pred_error_reduction <- 100 * (1 - oligos_pred_error[,"1.999.error"]/basic_rates)
oligos_pred_nseqs_reduction <- 100 * (1 - oligos_pred_error[,"1.999.frac"])
```

```{r coverage_pred_error_analysis}
get_coverage_pred <- function(region){
	region_data <- mock_error_basic[mock_error_basic$region == region,]

	good <- region_data$coverage >= 10 & region_data$pred_error >= 0.999
	region_data_good <- region_data[good,]

	c(100 * mean(region_data_good[,"error"]), nrow(region_data_good)/nrow(region_data) )
}

coverage_pred_error <- matrix(unlist(lapply(regions, get_coverage_pred)), ncol=2, byrow=T)
rownames(coverage_pred_error) <- regions
colnames(coverage_pred_error) <- c("10.999.error", "10.999.frac")

#    10.999.error 10.999.frac
#V1V3   0.2843963    65.86436
#V1V5   0.2188792    56.55108
#V1V6   0.2178326    57.33756
#V1V9   0.2191284    42.66675
#V3V5   0.2236951    60.74254
#V4     0.3527900    61.79213

coverage_pred_error_reduction <- 100 * (1 - coverage_pred_error[,"10.999.error"]/basic_rates)
coverage_pred_nseqs_reduction <- 100 * (1 - coverage_pred_error[,"10.999.frac"])
```

```{r all_filters_analysis}
get_all_filters <- function(region){
	region_data <- mock_error_basic[mock_error_basic$region == region,]

	good0 <- region_data$pbdiffs == 0 & region_data$pred_error >= 0.999 & region_data$coverage >= 10
	region_data_good0 <- region_data[good0,]

	good1 <- region_data$pbdiffs <= 1 & region_data$pred_error >= 0.999 & region_data$coverage >= 10
	region_data_good1 <- region_data[good1,]

	c(	100 * mean(region_data_good0[,"error"]), nrow(region_data_good0)/nrow(region_data),
		100 * mean(region_data_good1[,"error"]), nrow(region_data_good1)/nrow(region_data) )
}

all_filters_error <- matrix(unlist(lapply(regions, get_all_filters)), ncol=4, byrow=T)
rownames(all_filters_error) <- regions
colnames(all_filters_error) <- c("0.10.999.error", "0.10.999.frac", "1.10.999.error", "1.10.999.frac")

#    0.10.60.error 0.10.60.frac 1.10.60.error 1.10.60.frac
#v4    0.001515500    0.5562125   0.001993325    0.7499762
#v13   0.009299146    0.4337597   0.009827404    0.6155779
#v35   0.008613200    0.4862353   0.008979207    0.6253128
#v15   0.003078476    0.3488609   0.003905562    0.5268616
#v16   0.007738039    0.2954687   0.008814923    0.4295469
#v19   0.004797594    0.2496316   0.005266467    0.3631005

#     0.10.999.error 0.10.999.frac 1.10.999.error 1.10.999.frac
#V1V3      0.2808218     0.4696170      0.2840387     0.6183602
#V1V5      0.2184805     0.4192252      0.2182989     0.5374066
#V1V6      0.2170989     0.4182253      0.2174090     0.5421862
#V1V9      0.2176989     0.3213802      0.2191334     0.4016057
#V3V5      0.2241187     0.5038275      0.2240779     0.5841414
#V4        0.3492870     0.3932393      0.3526755     0.5665274

all_filters_error_reduction <- 100 * (1 - all_filters_error[,"1.10.999.error"]/basic_rates)
all_filters_nseqs_reduction <- 100 * (1 - all_filters_error[,"1.10.999.frac"])
```


```{r summary}
base_error_reduction <- rbind(	pb_error_reduction_0,
								pb_error_reduction_1,
								pred_error_reduction,
								coverage_error_reduction,
								coverage_pred_error_reduction,
								oligos_coverage_error_reduction,
								oligos_pred_error_reduction,
								all_filters_error_reduction)

base_nseqs_reduction <- rbind(	pb_nseqs_reduction_0,
								pb_nseqs_reduction_1,
								pred_nseqs_reduction,
								coverage_nseqs_reduction,
								coverage_pred_nseqs_reduction,
								oligos_coverage_nseqs_reduction,
								oligos_pred_nseqs_reduction,
								all_filters_nseqs_reduction)
```

***Identifying correlates of increased sequencing error.***
In contrast to the 454 and Illumina-based platforms where the sequencing
quality decays with length, the consensus sequencing approach employed by the
PacBio sequencer is thought to generate a uniform distribution of errors. This
makes it impossible to simply trim sequences to high quality regions. Therefore,
we sought to identify characteristics within sequences that would allow us to
identify and remove those sequences with errors using three different
approaches. First, we hypothesized that errors in the barcode and primer would
be correlated with the error rate for the entire sequence. We observed a strong
relationship between the number of mismatches to the barcodes and primers and the
error rate of the rest of the sequence fragment (Figure 1B). Although
allowing no mismatches to the barcodes and primers yielded the lowest error rate,
that stringent criterion removed a large fraction of the reads from the dataset.
Allowing at most one mismatch only marginally increased the error rate while
retaining more sequences in the dataset (Figure 2). Second, we hypothesized that
increased sequencing coverage should yield lower error rates. We found that once
we had obtained 10-fold coverage of the fragments, the error rate did not change
appreciably (Figure 1C). When we compared the error rates of reads with at least
10-fold coverage to those with less coverage, we reduced the error rate by
`r paste(format(range(coverage_reduction), digits=3, nsmall=1), collapse=" to ")`%
(Figure 2). Third, based on the earlier analysis finding a relationship between the
predicted error rate and the observed error rate, we sought a minimum predicted
error rate that would allow us to reduce the observed error rate. The average
observed error rate for sequences with predicted error rates between 0.01 and
0.10% was linear (Figure 1D). We decided to use a threshold of 0.01% because a
large number of sequence reads were lost when we used a smaller threshold. When
we used this threshold, we were able to reduce the error rate by
`r paste(format(range(pred_error_reduction), digits=3, nsmall=1), collapse=" to ")`%
(Figure 2A). Finally, we quantified the effect of combining filters. We found that
any combination of filters that included the predicted error rate threshold had
the most significant impact on reducing the observed error rate. Furthermore,
the inclusion of the mismatch and coverage filters had a negligible impact on
error rates, but had a significant impact on the number of sequences included in
the analysis. For instance, among the V1-V9 data, requiring sequences to have a
predicted error rate less than 0.01% resulted in a `r format(base_error_reduction["pred_error_reduction","V1V9"], digits=3, nsmall=1)`% and resulted in the removal of `r format(base_nseqs_reduction["pred_error_reduction","V1V9"], digits=3, nsmall=1)`% of the sequences. Adding the mismatch or coverage filter
had no effect on the reduction of error, but resulted in the removal of
`r format(base_nseqs_reduction["oligos_pred_nseqs_reduction","V1V9"], digits=3, nsmall=1)` and
`r format(base_nseqs_reduction["coverage_pred_nseqs_reduction","V1V9"], digits=3, nsmall=1)`% of the sequences, respectively. Use of all filters had no impact on the reduction in the observed
error rate, but resulted in the removal of `r format(base_nseqs_reduction["all_filters_nseqs_reduction","V1V9"], digits=3, nsmall=1)`% of the sequences. The remainder of this paper only uses sequences
with a predicted error rate less than 0.01%.

```{r precluster}
summarizeError <- function(folder, method){
  file1 <- paste("analysis/", folder, "/", folder, ".mock1.", method, ".error.summary", sep="")
  file2 <- paste("analysis/", folder, "/", folder, ".mock2.", method, ".error.summary", sep="")
  file3 <- paste("analysis/", folder, "/", folder, ".mock3.", method, ".error.summary", sep="")

  summary <- rbind(read.table(file=file1, header=T, row.names=1), read.table(file=file2, header=T, row.names=1), read.table(file=file3, header=T, row.names=1))
  nochim <- summary[summary$numparents==1,]
  error <- sum(nochim$weight * nochim$mismatches) / sum(nochim$weight * nochim$total)
  return(error)
}

unique.error <- unlist(lapply(regions, summarizeError, "unique"))
precluster.error <- unlist(lapply(regions, summarizeError, "precluster"))
final.error <- cbind(unique.error, precluster.error)
rownames(final.error) <- regions

#    unique.error precluster.error
#v4   0.002277391      0.001418871
#v13  0.009081866      0.007722886
#v35  0.009719159      0.008257968
#v15  0.004740243      0.002645747
#v16  0.007130228      0.005676505
#v19  0.005158478      0.003163881


reduction <- 100*(1-final.error[,"precluster.error"]/final.error[,"unique.error"])
rnd.reduction <- round(reduction, 0)
min.rnd.red <- min(rnd.reduction)
max.rnd.red <- max(rnd.reduction)

min.region <- paste(pretty.region[names(rnd.reduction[rnd.reduction==min.rnd.red])],collapse=" and ")

max.region <- pretty.region[[names(rnd.reduction[rnd.reduction==max.rnd.red])]]
```

***Pre-clustering sequences to further reduce sequencing noise.***
Previously, we implemented a pre-clustering algorithm where sequences were sorted
by their abundance in decreasing order and rare sequences are clustered with a
more abundant sequence if the rare sequences have fewer mismatches than a
defined threshold when compared to the more abundant sequence. The recommended
threshold was a 1-nt difference per 100-nt of sequence data. For example, the
threshold for 250 bp fragment from the V4 region would be 2 nt or 14 for the
1458 bp V1-V9 fragments. This approach removes residual PCR and sequencing
errors while not overwhelming the resolution needed to identify OTUs that are
based on a 3% distance threshold. The tradeoff of this approach is that one would
unable to differentiate V1-V9 sequences that truly differed by less than 14 nt.
When we applied
this approach to our PacBio data, we observed a reduction in the error rate
between `r min.rnd.red` (`r min.region`) and `r max.rnd.red`% (`r max.region`).
The final error rates varied between
`r round(min(100*final.error[,"precluster.error"]), digits=2)`
(`r pretty.region[names(which.min(final.error[,"precluster.error"]))]`)
and `r round(max(100*final.error[,"precluster.error"]), digits=2)`%
(`r pretty.region[names(which.max(final.error[,"precluster.error"]))]`); the
full-length, V1-V9, fragments had an error rate of
`r round(100* final.error["v19","precluster.error"], digits=2)`%
(Figure 2B). These error rates are 7-40
times higher than what we have previously observed using the 454 and
Illumina MiSeq platforms (0.02%){Schloss, 2011 #2466; Kozich, 2013 #2719}



```{r}
getOTUResults <- function(region){
  perfect <- read.table(file=paste0("analysis/", region, "/HMP_MOCK.filter.pick.phylip.an.summary"), header=T)
  nochims <- read.table(file=paste0("analysis/", region, "/", region, ".mock.precluster.perfect.pick.an.ave-std.summary"), header=T)
  observed <- read.table(file=paste0("analysis/",region, "/", region, ".trim.unique.good.filter.unique.precluster.pick.an.merge.groups.ave-std.summary"), header=T)
	obs.mock <- observed[observed$group=="mock"   & observed$method=="ave", "sobs"]
	obs.soil <- observed[observed$group=="soil"   & observed$method=="ave", "sobs"]
	obs.mouse <- observed[observed$group=="mouse" & observed$method=="ave", "sobs"]
	obs.human <- observed[observed$group=="human" & observed$method=="ave", "sobs"]
	nseqs <- nochims[nochims$method=="ave", "nseqs"]

	return(c(perfect[1,2], nochims[1,3], obs.mock, obs.soil, obs.mouse, obs.human, nseqs))
}

otu.table <- t(sapply(regions, getOTUResults))
nseqs <- otu.table[1,7]
perfect.otu <- otu.table[1,1]
otu.table <- otu.table[,-c(1,7)]

otu.table <- cbind(100 * final.error[rownames(otu.table),"precluster.error"], otu.table)
colnames(otu.table) <- c("Error Rate (%)", "Mock with no chimeras", "Observed mock", "Soil", "Mouse", "Human")
rownames(otu.table) <- pretty.region[rownames(otu.table)]

#kable(otu.table, digits=c(2, rep(1,5)))

#|      | Error Rate (%)| Mock with no chimeras| Observed mock|  Soil| Mouse| Human|
#|:-----|--------------:|---------------------:|-------------:|-----:|-----:|-----:|
#|V4    |           0.14|                  26.0|          27.4| 335.8|  78.5|  58.1|
#|V1-V3 |           0.77|                  53.6|          77.0| 436.6| 159.7| 116.8|
#|V3-V5 |           0.83|                  83.1|         106.8| 388.9| 259.6|  91.6|
#|V1-V5 |           0.26|                  34.6|          40.7| 403.2|  88.8|  74.7|
#|V1-V6 |           0.57|                  57.4|          89.7| 431.9| 138.3|  95.9|
#|V1-V9 |           0.32|                  29.5|          41.8| 390.9|  81.9| 102.0|

getCoverage <- function(region){
  observed <- read.table(file=paste0("analysis/",region, "/", region, ".trim.unique.good.filter.unique.precluster.pick.an.merge.groups.ave-std.summary"), header=T)
	obs.mock <- observed[observed$group=="mock"   & observed$method=="ave", "coverage"]
	obs.soil <- observed[observed$group=="soil"   & observed$method=="ave", "coverage"]
	obs.mouse <- observed[observed$group=="mouse" & observed$method=="ave", "coverage"]
	obs.human <- observed[observed$group=="human" & observed$method=="ave", "coverage"]

	return(c(obs.mock, obs.soil, obs.mouse, obs.human))
}

coverage.table <- t(sapply(regions, getCoverage))
colnames(coverage.table) <- c("Mock", "Soil", "Mouse", "Human")
rownames(coverage.table) <- pretty.region[rownames(coverage.table)]
```

***Effects of error rates on OTU assignments.***
The sequencing error rate is known to affect the number of OTUs that are
observed {Schloss, 2011 #2466}. For each region, we determined that if there were no chimeras or
PCR or sequencing errors, then we would expect to find `r perfect.otu[[1]]` OTUs. When
achieved perfect chimera removal, but allowed for PCR and sequencing errors, we
observed between `r diff<-otu.table[,2]-perfect.otu;
round(min(diff), digits=1)` (`r names(which.min(diff))`) and `r round(max(diff), digits=1)`
(`r names(which.max(diff))`) extra OTUs. The range in the number of extra OTUs was largely
explained by the sequencing error rate (Pearson's R=`r round(cor.test(diff, final.error[,"precluster.error"])$estimate, 2)`). Next, we determined
the number of OTUs that were observed when we used UCHIME to identify chimeric sequence.
Under these more realistic conditions, we observed between `r diff<-otu.table[,3]-perfect.otu;
round(min(diff), digits=1)` (`r names(which.min(diff))`) and `r round(max(diff), digits=1)`
(`r names(which.max(diff))`) extra OTUs. Finally, we calculated the number of OTUs in the
soil, mouse, and human samples using the same pipeline with chimera detection and removal
based on the UCHIME algorithm. Again, we found that there was a strong correlation between
the number of observed OTUs and the error rate for the
soil (R=`r format(round(cor.test(otu.table[,"Soil"], final.error[,"precluster.error"])$estimate, 2), nsmall=2)`),
mouse (R=`r format(round(cor.test(otu.table[,"Mouse"], final.error[,"precluster.error"])$estimate, 2), nsmall=2)`),
and human samples (R=`r format(round(cor.test(otu.table[,"Human"], final.error[,"precluster.error"])$estimate, 2), nsmall=2)`).
These results underscore the effect of sequencing error on the inflation of the number of
observed OTUs.


```{r, classificationSummary}
data <- read.table(file="taxonomy.depth.analysis", header=T)

rdp <- cbind("Mock"=data[data$database=="rdp" & data$sample=="mock", "total"],
						 "Human"=data[data$database=="rdp" & data$sample=="human", "total"],
						 "Mouse"=data[data$database=="rdp" & data$sample=="mouse", "total"],
						 "Soil"=data[data$database=="rdp" & data$sample=="soil", "total"])
rownames(rdp) <- c("V4", "V3-V5", "V1-V3", "V1-V5", "V1-V6", "V1-V9")

gg <- cbind("Mock"=data[data$database=="gg" & data$sample=="mock", "total"],
						"Human"=data[data$database=="gg" & data$sample=="human", "total"],
						"Mouse"=data[data$database=="gg" & data$sample=="mouse", "total"],
						"Soil"=data[data$database=="gg" & data$sample=="soil", "total"])
rownames(gg) <- c("V4", "V3-V5", "V1-V3", "V1-V5", "V1-V6", "V1-V9")

silva <- cbind("Mock"=data[data$database=="silva" & data$sample=="mock", "total"],
							 "Human"=data[data$database=="silva" & data$sample=="human", "total"],
							 "Mouse"=data[data$database=="silva" & data$sample=="mouse", "total"],
							 "Soil"=data[data$database=="silva" & data$sample=="soil", "total"])
rownames(silva) <- c("V4", "V3-V5", "V1-V3", "V1-V5", "V1-V6", "V1-V9")

gg.sp <- cbind("Mock"=data[data$database=="gg" & data$sample=="mock", "X7"],
							 "Human"=data[data$database=="gg" & data$sample=="human", "X7"],
							 "Mouse"=data[data$database=="gg" & data$sample=="mouse", "X7"],
							 "Soil"=data[data$database=="gg" & data$sample=="soil", "X7"])
rownames(gg.sp) <- c("V4", "V3-V5", "V1-V3", "V1-V5", "V1-V6", "V1-V9")
```

***Increasing sequence length improves classification.***
We classified all of the sequence data we generated using the naïve Bayesian
classifier using the RDP, SILVA, and greengenes reference taxonomies (Figure
4). In general, increasing the length of the region improved the
ability to assign the sequence to a genus or species. Interestingly, each of the
samples we analyzed varied in the ability to assign its sequences to the depth of
genus or species. Furthermore, the reference database that did the best job of
classifying the sequences varied by sample type. For example, the SILVA
reference did the best for the human feces and soil samples and the RDP did the
best for the mouse feces samples. An advantage of the greengenes database is
that it contains
information for 2,514 species-level lineages for 11% of the reference sequences;
the other databases only provided taxonomic data to the genus level. There was a
modest association between the length of the fragment and the
ability to classify sequences to the species-level for the human samples; there
was no such association for the mouse and soil samples. In fact, at most
`r format(round(max(gg.sp[,"Soil"]), digits=1), nsmall=1)`% of
the soil sequences and `r format(round(max(gg.sp[,"Mouse"]), digits=1), nsmall=1)`%
of the mouse sequences could be classified to a
species. These results indicate that the ability to classify sequences to the
genus or species level is a function of read length, sample type, and the
reference database.  


```{r}
error <- read.table(file="analysis/v4/v4.trim.unique.good.filter.unique.pick.error.summary", header=T, row.names=1)
error.nochim <- error[error$numparents==1,]
one.off <- error.nochim[error.nochim$mismatches==1,]
one.off.sum <- sum(one.off$weight)
v4.table <- table(one.off$weight)
v4.total <- sum(error$weight)

error <- read.table(file="analysis/v35/v35.trim.unique.good.filter.unique.pick.error.summary", header=T, row.names=1)
error.nochim <- error[error$numparents==1,]
one.off <- error.nochim[error.nochim$mismatches==1,]
one.off.sum <- sum(one.off$weight)
v35.table <- table(one.off$weight)
v35.total <- sum(error$weight)

error <- read.table(file="analysis/v15/v15.trim.unique.good.filter.unique.pick.error.summary", header=T, row.names=1)
error.nochim <- error[error$numparents==1,]
one.off <- error.nochim[error.nochim$mismatches==1,]
one.off.sum <- sum(one.off$weight)
v15.table <- table(one.off$weight)
v15.total <- sum(error$weight)
```

***Sequencing errors are not random.***
Above, we described that although there was no obvious bias in the substitution
or insertion rate, we did observe that guanines and cytosines were more likely
to be deleted than adenines and thymidines. This lack of randomness in the error
profile suggested that there might be a systematic non-random distribution of
the errors across the sequences. This would manifest itself by the creation of
duplicate sequences with the same error. Because we were able to obtain a large
number of reads from the mock communities where we sequenced the V4
(N=`r v4.total`), V1-V5 (N=`r v15.total` sequences), and V3-V5 (N=`r v35.total`)
regions, we investigated the mock community data from these regions further. We
identified all of the sequences that had a 1-nt difference to the true sequence.
For these three regions, a majority of the sequences with 1-nt errors were only
observed once (V4: `r round(100*v4.table[1]/sum(v4.table), 1)`%, V1-V5:
`r round(100*v15.table[1]/sum(v15.table), 1)`%, V3-V5:
`r round(100*v35.table[1]/sum(v35.table), 1)`%). We found that the frequency of the
most abundant 1-nt error paralleled the number of sequences. There were two sequences
in the V4 dataset that occurred `r names(v4.table[length(v4.table)])` times, one
sequence in the V1-V5 dataset that occurred `r names(v15.table[length(v15.table)])`
times, and one sequence in the V3-V5 dataset that occurred
`r names(v35.table[length(v35.table)])` times. Contrary to previous reports
{Carneiro, 2012 #3458;Koren, 2012 #3459}, these results indicate that
reproducible errors occur with the PacBio sequencing platform and that they can be
quite frequent.


## Conclusions
The various sequencing platforms that are available to microbial ecologists are
able to fill unique needs and have their own strengths and weaknesses. For
sequencing the 16S rRNA gene, the 454 platform is able to generate a moderate
number of high-quality 500-nt sequence fragments (error rates below 0.02%) {Schloss, 2011 #2466} and
the MiSeq platform is able to generate a large number of high-quality 250-nt
sequence fragments (error rates below 0.02%) {Kozich, 2013 #2719}. The promise of the PacBio
sequencing platform was the generation of high-quality near full-length sequence
fragments. As we have shown in this study, it is possible to generate near
full-length sequences; however, the error rate associated with those reads is
considerable (i.e. `r round(100*final.error["v19","precluster.error"],2)`%)
and requires a level of sequencing coverage that is not commonly observed in a
typical sequencing run. This results in the generation of a small number of low
quality full-length sequences. When we considered the shorter V4 region, which is
similar in length to what is sequenced by the MiSeq platform, the error rates
we observed with the PacBio platform were nearly 5-fold higher than what has
previously been reported. It appears that the promise offered by the PacBio
platform has not been realized.

The widespread adoption of the 454 and MiSeq platforms and decrease in the use
of Sanger
sequencing for the 16S rRNA gene has resulted in a decrease in the
generation of the full-length reference sequences that are needed for performing
phylogenetic analyses and designing lineage specific PCR primers and fluorescent
*in situ* hybridization (FISH) probes. It remains to be determined whether the
elevated error rates we observed for full-length sequences are prohibitive for
these applications. We can estimate the distribution of errors assuming that the
errors follow a binomial distribution along the length of the 1,500 nt
gene with the error rate that we achieved from the V1-V9 mock community data
prior to pre-clustering the sequences, which was
`r round(100*final.error["v19","unique.error"],2)`% (Figure 5). Under
these conditions one would only expect
`r round(100*dbinom(0, 1500, final.error["v19","unique.error"]), 2)`% of the
sequences to have no errors. In fact, 95% of the reads would have at least
`r qbinom(0.05, 1500, final.error["v19","unique.error"])` errors and 50% of the
reads would have at least
`r qbinom(0.50, 1500, final.error["v19","unique.error"])` errors. If the error
rate could be dropped to 0.25%, then 95% of
the reads would have at least
`r qbinom(0.05, 1500, 0.0025)` error and 50% of the
reads would have at least
`r qbinom(0.50, 1500, 0.0025)` errors. If it were possible to replicate the low
error rates we have previously observed using the 454 and Illumina MiSeq
platforms, which was 0.02%, then we would expect
`r round(100*dbinom(0, 1500, 0.0002), 1)`% of the sequences to have no errors.
In fact, 95% of the reads would have `r qbinom(0.95, 1500, 0.0002)` or fewer
errors. Although full-length sequence data is highly desired, at this point, it
does not appear that the PacBio platform can provide the data of sufficient
quality to fill the niche of generating reference sequences.

Full-length sequences are frequently seen as a panacea to overcome the
limitations of taxonomic classifications. The ability to classify each of our
sample types benefited from the generation of full-length sequences. It was
interesting that the benefit varied by sample type and database. For example,
using the mouse libraries, the ability to classify each of the regions differed
by less than 5%
when classifying against the SILVA and greengenes databases. The effect of the
database that was used was also interesting. The RDP database outperformed the
other databases for the mouse samples and the SILVA database outperformed the
others for the human and soil samples. The three databases were equally
effective for classifying the mock community. Finally, since only the
greengenes database provided species-level information for its reference
sequences it was the only database that allowed for resolution of species-level
classification. The sequences from the mouse and soil libraries were not
effectively classified to the species level (all less than 10%). In contrast,
classification of the human libraries resulted in more than 40% of the sequences
being classified to a genus, regardless of the region. That the variation in
species-level classification for the human libraries was less than 10% suggests
that the benefit of added length is minimal considering the lower sequencing
yield.

The development of newer sequencing technologies continue to advance
and there is justifiable excitement to apply these technologies to sequence the
16S rRNA gene. Although it is clearly possible to generate sequencing data from
these various platforms, it is critical that we assess the platforms for their
ability to generate high quality data and the particular niche that the new
approach will fill. With this in mind, it is essential that researchers utilize
mock communities as part of their experimental design so that they can quantify
their error rates. The ability to generate large numbers of near full-length 16S
rRNA gene sequences is an exciting advance. At this point, the excitement must
be tempered by the appreciation that the error rates limit the application of
the approach.


## Acknowledgements
The Genomic DNA from Microbial Mock Community A (Even, Low Concentration, v3.1,
HM-278D) was obtained through the NIH Biodefense and Emerging Infections
Research Resources Repository, NIAID, NIH as part of the Human Microbiome
Project.


## Funding statement
This study was supported by grants from the NIH (R01HG005975, R01GM099514 and
P30DK034933 to PDS and U54HG004973 to SKH).


## References



## Tables

**Table 1. Summary of the primer pairs used to generate the 16S rRNA gene fragment fragments and the characteristics of each region.**

```{r Table_1, warning=TRUE, results='asis'}

getSloppyRevComp <- function(sequence){
	rev.sequence <- paste(rev(unlist(strsplit(sequence, ""))), collapse="")
	revcomp.sequence <- chartr("ATGCRYSWKMBDHVN", "TACG...........", rev.sequence)
	return(revcomp.sequence)
}

getPos <- function(primer, sequence=ecoli, forward=TRUE){
	if(forward==FALSE){
		primer <- getSloppyRevComp(primer)
	}
	primer <- gsub("[^ATGC]", ".", primer)

	pos <- regexpr(primer, sequence)

	if(forward==FALSE){
		pos <- pos + nchar(primer) -1
	}
	return(pos)

}

#taken from... http://www.ncbi.nlm.nih.gov/nuccore/NC_022648.1?report=fasta&from=4564120&to=4565661
ecoli <- "AAATTGAAGAGTTTGATCATGGCTCAGATTGAACGCTGGCGGCAGGCCTAACACATGCAAGTCGAACGGTAACAGGAAGCAGCTTGCTGCTTTGCTGACGAGTGGCGGACGGGTGAGTAATGTCTGGGAAACTGCCTGATGGAGGGGGATAACTACTGGAAACGGTAGCTAATACCGCATAACGTCGCAAGACCAAAGAGGGGGACCTTCGGGCCTCTTGCCATCGGATGTGCCCAGATGGGATTAGCTAGTAGGTGGGGTAACGGCTCACCTAGGCGACGATCCCTAGCTGGTCTGAGAGGATGACCAGCCACACTGGAACTGAGACACGGTCCAGACTCCTACGGGAGGCAGCAGTGGGGAATATTGCACAATGGGCGCAAGCCTGATGCAGCCATGCCGCGTGTATGAAGAAGGCCTTCGGGTTGTAAAGTACTTTCAGCGGGGAGGAAGGGAGTAAAGTTAATACCTTTGCTCATTGACGTTACCCGCAGAAGAAGCACCGGCTAACTCCGTGCCAGCAGCCGCGGTAATACGGAGGGTGCAAGCGTTAATCGGAATTACTGGGCGTAAAGCGCACGCAGGCGGTTTGTTAAGTCAGATGTGAAATCCCCGGGCTCAACCTGGGAACTGCATCTGATACTGGCAAGCTTGAGTCTCGTAGAGGGGGGTAGAATTCCAGGTGTAGCGGTGAAATGCGTAGAGATCTGGAGGAATACCGGTGGCGAAGGCGGCCCCCTGGACGAAGACTGACGCTCAGGTGCGAAAGCGTGGGGAGCAAACAGGATTAGATACCCTGGTAGTCCACGCCGTAAACGATGTCGACTTGGAGGTTGTGCCCTTGAGGCGTGGCTTCCGGAGCTAACGCGTTAAGTCGACCGCCTGGGGAGTACGGCCGCAAGGTTAAAACTCAAATGAATTGACGGGGGCCCGCACAAGCGGTGGAGCATGTGGTTTAATTCGATGCAACGCGAAGAACCTTACCTGGTCTTGACATCCACGGAAGTTTTCAGAGATGAGAATGTGCCTTCGGGAACCGTGAGACAGGTGCTGCATGGCTGTCGTCAGCTCGTGTTGTGAAATGTTGGGTTAAGTCCCGCAACGAGCGCAACCCTTATCCTTTGTTGCCAGCGGTCCGGCCGGGAACTCAAAGGAGACTGCCAGTGATAAACTGGAGGAAGGTGGGGATGACGTCAAGTCATCATGGCCCTTACGACCAGGGCTACACACGTGCTACAATGGCGCATACAAAGAGAAGCGACCTCGCGAGAGCAAGCGGACCTCATAAAGTGCGTCGTAGTCCGGATTGGAGTCTGCAACTCGACTCCATGAAGTCGGAATCGCTAGTAATCGTGGATCAGAATGCCACGGTGAATACGTTCCCGGGCCTTGTACACACCGCCCGTCACACCATGGGAGTGGGTTGCAAAAGAAGTAGGTAGCTTAACCTTCGGGAGGGCGCTTACCACTTTGTGATTCATGACTGGGGTGAAGTCGTAACAAGGTAACCGTAGGGGAACCTGCGGTTGGATCACCTCCTTA"



oligos <- read.table(file="pacbio.oligos", stringsAsFactors=F)[1:6,]
rownames(oligos) <- pretty.region[oligos$V4]
oligos <- oligos[,c("V2", "V3")]
colnames(oligos) <- c("Forward", "Reverse")

start <- sapply(oligos[,1], getPos)
end <- sapply(oligos[,2], getPos, forward=FALSE)


coordinates <- paste(start, end, sep="-")
length <- end - start - nchar(oligos[,1]) - nchar(oligos[,2]) + 1
t1 <- cbind(oligos, coordinates, length)
knitr::kable(t1, digits=1, row.names=TRUE, col.names=c("Forward", "Reverse", "*E. coli* coordinates^a^", "Length (bp)^b^"), align=c("l", "l", "c", "c"))
```

^a^	The coordinates where the start and end of the forward and reverse primers anneal, respectively.

^b^	The number of bases between the primers.



**Table 2. Summary of the reasons that sequences were excluded because of the
basic sequence curation steps**

```{r Table_2, warning=TRUE, results='asis'}
rownames(reasons.lost) <- pretty.region[rownames(reasons.lost)]
reasons.lost <- cbind(orig.nseqs, 100*reasons.lost, basic.nseqs)
knitr::kable(reasons.lost, digits=1, row.names=TRUE,
						 col.names=c("Initial sequences (N)", "Good reads (%)",
						 						"Wrong start/end position (%)",
						 						"Excessively long homopolymers (%)",
						 						"Ambiguous base calls (%)",
						 						"Sequences remaining (N\\)"),
						 align="c")
```


## Figures

[revise - Fig 1A plot predicted error rate vs observed error rate]
**Figure 1. Summary of errors in data generated using PacBio sequencing platform
to sequence various regions within the 16S rRNA gene.** Quality scores varied
with error types (A). The sequencing error rate of the amplified gene fragments
increased with mismatches to the barcodes and primers (B). The sequencing error
rate declined with increasd sequencing coverage; however, increasing the
sequencing depth beyond 10-fold coverage had no meaningful effect on the
sequencing error rate (C).


**Figure 2. Change in error rate (A) and the percentage of sequences that were
retained (B) when using various sequence curation methods.** The condition that
was used for downstream analyses is indicated by the star. The plotted numbers
represent the region that was sequenced. For example "15" represents the data
for the V1-V5 region.


**Figure 3. The relationship between the error rate of each region and the
composite quality scores for the sequences.** The error rates (A and C) and
percentage of sequences (B and D) were calculated for the reads that had a
composite quality score above the plotted value. The composite quality scores
were calculated by either determining the minimum value of the average quality
score wihin all 50-nt windows within each region (A and B) or by calculating
the average quality score across the entire sequence read (C and D).


**Figure 4. Percentage of unique sequences that could be classified.**
Classifications were performed using taxonomy references curated from the RDP,
SILVA, or greengenes databases for the four types of samples that were sequenced
across the six regions from the 16S rRNA gene. Only the greengenes taxonomy
reference provided species-level information.

**Figure 5. The percentage of V1-V9 sequences that were predicted to have
between 0 and 20 errors as a function of the error rate of the sequences.** The
highest error rate, `r round(100*final.error["v19","unique.error"], 2)`%,
corresponds to what was observed before the pre-clustering step.
The smallest error rate (0.02%) corresponds to our previous observations using
the 454 and MiSeq sequencing platforms. The predicted number of errors was
assumed to follow a binomial distribution.



### Figure 1
```{r Figure_1, fig.width=6.5, fig.height=3.0}
layout(matrix(c(1,2,3), nrow=1), heights=1, widths=c(0.75,1,1))


#Panel A depicting range of quality scores for different errors
par(mar=c(6, 5, 0.5, 0.5))
plot(1, xlim=c(0.5, 4.5), ylim=c(0,75), type="n", yaxt="n", xaxt="n", xlab="",
		 ylab="")
polygon(x=c(0.75, 1.25, 1.25, 0.75), y=c(m.quant["25%"], m.quant["25%"],
																				 m.quant["75%"], m.quant["75%"]))
polygon(x=c(1.75, 2.25, 2.25, 1.75), y=c(s.quant["25%"], s.quant["25%"],
																				 s.quant["75%"], s.quant["75%"]))
polygon(x=c(2.75, 3.25, 3.25, 2.75), y=c(i.quant["25%"], i.quant["25%"],
																				 i.quant["75%"], i.quant["75%"]))
polygon(x=c(3.75, 4.25, 4.25, 3.75), y=c(a.quant["25%"], a.quant["25%"],
																				 a.quant["75%"], a.quant["75%"]))

segments(x0=seq(0.75, 3.75, 1), x1=seq(1.25,4.25,1), y0=c(m.quant["50%"],
											s.quant["50%"], i.quant["50%"], a.quant["50%"]), lwd=4)

arrows(x0=1:4, y0=c(m.quant["75%"], s.quant["75%"], i.quant["75%"],
										a.quant["75%"]), y1=c(m.quant["97.5%"], s.quant["97.5%"],
																					i.quant["97.5%"], a.quant["97.5%"]),
			 angle=90, length=0.05)

arrows(x0=1:4, y0=c(m.quant["25%"], s.quant["25%"], i.quant["25%"],
										a.quant["25%"]), y1=c(m.quant["2.5%"], s.quant["2.5%"],
																					i.quant["2.5%"], a.quant["2.5%"]),
			 angle=90, length=0.05)

axis(1, at=c(1,2,3,4), label=c("Matches", "Substitutions", "Insertions",
															 "Ambiguous"), las=2, cex.axis=1)
axis(2, las=2, at=c(0,25,50,75), cex.axis=1.5)
title(ylab="Quality score", cex.lab=1.5)
mtext(side=2, line=2.5, at=75, text="A", cex=2, font=2, las=2)


#Panel B depicting relationship between errors in barcodes/primers and the
#rest of the sequence.
par(mar=c(5,5,0.5,0.5))
plot(err.bcprimer$x[1:6,1]~err.bcprimer$Group.1[1:6], pch=19,
		 ylab="Error rate (%)", xlab="", axes=F, ylim=c(0,5), cex.lab=1.5)
mtext(side=1, line=3.75, text="Total mismatches to\nbarcodes and primers",
			cex=0.9)
axis(1, cex.axis=1.5)
axis(2, las=2, cex.axis=1.5)
box()
mtext(side=2, line=2.5, at=5, text="B", cex=2, font=2, las=2)


#Panel C depicting relationship between sequencing coverage and error rate for
#the different regions that were sequence
plotLines <- function(folder){
	composite <- read.table(file=paste("pipeline_dev/", folder, "/", folder,
																		 ".composite", sep=""),
													header=T,row.names=1)

	composite <- composite[composite$reason=="g",]
	error.by.depth <- aggregate(composite$error, by=list(composite$freq),
															function(x){c(mean=mean(x),
																						quantile(x, prob=c(0.025, 0.975)),
																						n=length(x))})

	#exclude any coverage values where we don't have at least 50 observations
	error.by.depth <- error.by.depth[error.by.depth$x[,"n"]>=50,]
	fold.coverage <- error.by.depth[, "Group.1"]
	error.by.depth <- error.by.depth$x

	mean <- error.by.depth[,"mean"]
	points(mean~fold.coverage, type="l", lwd=2, col=clrs[folder])
}

par(mar=c(5,2,0.5, 0.5))
plot(1, xlim=c(2,30), ylim=c(0,0.05), type="n", xlab="", ylab="", axes=F)
axis(2, at=seq(0,0.05, 0.01), label=FALSE, tick=T, las=2)
#axis(2, at=seq(0,0.05, 0.01), label=seq(0,5, 1), las=2)
axis(1, cex.axis=1.5)
lapply(regions, plotLines)
legend(x=18, y=0.05, legend=pretty.region[regions], lty=1, lwd=2, col=clrs[regions])
mtext(side=2, line=0.5, at=0.05, text="C", cex=2, font=2, las=2)
title(xlab="Coverage", ylab="", cex.lab=1.5)
box()

layout(1)
```



### Figure 2
```{r Figure_2, width=6.5, height=6}
error.fraction <- cbind(initial.error=init.rates, basic.error=basic.error,
												bcprimer.error, coverage.error, aveq.error,
												oligosCoverage.error, oligosQScore.error,
												coverageQScore.error, allFilters.error, final.error)
rownames(error.fraction) <- gsub("v(\\d*)", "\\1", rownames(error.fraction))

error <- 100 * error.fraction[,grepl("error", colnames(error.fraction))]
fraction <- 100 * error.fraction[,grepl("frac", colnames(error.fraction))]

getJitter <- function(x){
	jitter <- 0.15
	runif(6, x-jitter, x+jitter)
}

l <- layout(matrix(c(1,2,3), nrow=3), heights=c(1,1,0.6))

par(mar=c(0.5, 7, 0.5, 0.5))
plot(1, type="n", xlim=c(1, 14), ylim=c(0,2.5), axes=F, xlab="", ylab="",
		 cex.lab=1.5)
text(x=getJitter(1.0), y=error[,1], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(2.0), y=error[,2], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(3.0), y=error[,3], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(4.0), y=error[,4], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(5.0), y=error[,5], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(6.0), y=error[,6], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(7.0), y=error[,7], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(8.0), y=error[,8], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(9.0), y=error[,9], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(10.0), y=error[,10], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(11.0), y=error[,11], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(12.0), y=error[,12], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(13.0), y=error[,13], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(14.0), y=error[,15], label=rownames(error.fraction), cex=1.25)
text(x=10, y=2, label="*", cex=3, font=2)

mtext(text="Error rate (%)", side=2, line=4, cex.lab=1.2)
box()
axis(2, las=2, at=seq(0,2.5, 0.5), label=format(seq(0, 2.5, 0.5),nsmall=1),
		 cex.axis=1.5)

abline(v=seq(3.5,13.5, 1), col="grey")
abline(v=c(1.5, 2.5, 13.5), col="black", lwd=2)

mtext(side=2, line=4.5, at=2.44, text="A", cex=2, font=2, las=1)

par(mar=c(0.5, 7, 0.5, 0.5))
plot(1, type="n", xlim=c(1, 14), ylim=c(0,100), axes=F,
		 ylab="Reads remaining\nfrom basic criteria (%)", xlab="", cex.lab=1.5)
text(x=getJitter(3.0), y=fraction[,1], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(4.0), y=fraction[,2], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(5.0), y=fraction[,3], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(6.0), y=fraction[,4], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(7.0), y=fraction[,5], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(8.0), y=fraction[,6], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(9.0), y=fraction[,7], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(10.0), y=fraction[,8], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(11.0), y=fraction[,9], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(12.0), y=fraction[,10], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(13.0), y=fraction[,11], label=rownames(error.fraction), cex=1.25)
text(x=getJitter(14.0), y=fraction[,8], label=rownames(error.fraction), cex=1.25)

box()
abline(v=seq(3.5,13.5, 1), col="grey")
abline(v=c(1.5, 2.5, 13.5), col="black", lwd=2)

mtext(side=2, line=4.5, at=98, text="B", cex=2, font=2, las=1)
axis(2, las=2, at=seq(0,100, 25), label=seq(0, 100, 25), cex.axis=1.5)
text(1,0, label="NA")
text(2,0, label="NA")

plot(1, type="n", xlim=c(1, 14), ylim=c(0,1), axes=F, ylab="", xlab="")

text(x=c(1:14)+0.2, y=rep(1, 11), label=c("Initial data", "Basic criteria",
		"No Mismatches", "\u22641 Mismatch", "Coverage", "Quality Score",
		"No Mismatches\n& Coverage", "\u22641 Mismatch\n& Coverage",
		"No Mismatches\n& Quality", "\u22641 Mismatch\n& Quality",
		"Coverage & Quality", "No Mismatches,\nCoverage & Quality",
		"\u22641 Mismatch,\nCoverage & Quality", "After Pre-clustering"),
		srt=90, pos=2, cex=1)  

layout(1)
```




### Figure 3
```{r Figure_3, fig.height=6.5, fig.width=6.5}
aggregateErrorMinQualityScore <- function(folder){
	write(folder, "")
	composite <- read.table(file=paste("pipeline_dev/", folder, "/", folder,
																		 ".composite", sep=""), header=T,
													row.names=1)
	composite <- composite[composite$reason == "g",]

	remaining.error <- rep(0, max(composite$minQ)+1)
	qscores <- 0:max(composite$minQ)

	remaining.error <- unlist(lapply(qscores,
														function(x){mean(composite[composite$minQ >= x,"error"])}))
	names(remaining.error) <- qscores
	points(x=10:70, remaining.error[10:70], type="l", col=clrs[folder], lwd=2)
}

fractionMinQualityScore <- function(folder){
	write(folder, "")

	composite <- read.table(file=paste("pipeline_dev/", folder, "/", folder,
																		 ".composite", sep=""), header=T, row.names=1)
	composite <- composite[composite$reason == "g",]

	binned <- aggregate(composite$error, by=list(round(composite$minQ)), length)
	remaining <- 1-cumsum(binned$x)/sum(binned$x)
	points(binned$Group.1, remaining, type="l", col=clrs[folder], lwd=2)
}


aggregateErrorAveQualityScore <- function(folder){
	write(folder, "")
	composite <- read.table(file=paste("pipeline_dev/", folder, "/", folder,
																		 ".composite", sep=""), header=T, row.names=1)
	composite <- composite[composite$reason == "g",]

	remaining.error <- rep(0, max(composite$aveQ)+1)
	qscores <- 0:max(composite$aveQ)
	remaining.error <- unlist(lapply(qscores,
												function(x){mean(composite[composite$aveQ >= x,"error"])}))
	names(remaining.error) <- qscores
	points(x=10:70, remaining.error[10:70], type="l", col=clrs[folder], lwd=2)
}


fractionAveQualityScore <- function(folder){
write(folder, "")

	composite <- read.table(file=paste("pipeline_dev/", folder, "/", folder,
																		 ".composite", sep=""), header=T, row.names=1)
	composite <- composite[composite$reason == "g",]

	binned <- aggregate(composite$error, by=list(round(composite$aveQ)), length)

	remaining <- 1-cumsum(binned$x)/sum(binned$x)
	points(binned$Group.1, remaining, type="l", col=clrs[folder], lwd=2)
}

layout(1)
layout(matrix(c(1,2,3,4), nrow=2, byrow=F), width=c(1.1,1), height=c(1, 1.3))

#A
par(mar=c(0.5,5,0.5, 0.5))
plot(1, xlim=c(10,75), ylim=c(0,0.015), type="n", axes=F, xlab="", ylab="")
lapply(regions, aggregateErrorMinQualityScore)
mtext(side=2, line=2.5, text="Error rate of sequences\nabove threshold (%)", cex.lab=0.9)
axis(1, at=seq(10,70,10), label=F, tick=T)
axis(2, las=2, at=seq(0,0.015,0.005), label=format(seq(0,1.5,0.5), nsmall=1), cex.axis=1.25)
box()
mtext(side=2, line=2.6, at=0.015, text="A", las=2, cex=2, font=2)


#B
par(mar=c(6,5,0.5, 0.5))
plot(1, xlim=c(10,75), ylim=c(0,1), type="n", yaxt="n", xlab="", ylab="", cex.axis=1.25)
lapply(regions, fractionMinQualityScore)
mtext(side=1, line=4.25, text="Minimum average quality\nscore within a 50-nt window\nacross the full sequence", cex=0.9)
mtext(side=2, line=2.5, text="Sequences above\nthreshold (%)", cex.lab=0.9)

axis(2, las=2, at=seq(0,1,0.2), label=seq(0,100,20), cex.axis=1.25)
mtext(side=2, line=2.6, at=1, text="B", las=2, cex=2, font=2)


#C
par(mar=c(0.5,2,0.5, 0.5))
plot(1, xlim=c(10,75), ylim=c(0,0.015), type="n", axes=F, xlab="", ylab="")
lapply(regions, aggregateErrorAveQualityScore)
axis(1, at=seq(10,70,10), label=F, tick=T)
axis(2, at=seq(0,0.02,0.005), label=F, tick=T)
box()
mtext(side=2, line=0.6, at=0.015, text="C", las=2, cex=2, font=2)


#D
par(mar=c(6,2,0.5, 0.5))
plot(1, xlim=c(10,75), ylim=c(0,1), type="n", yaxt="n", xlab="", ylab="", cex.axis=1.25)
lapply(regions, fractionAveQualityScore)
mtext(side=1, text="Average quality score", cex=0.9, line=3)
title(ylab="Sequences above threshold (%)")
axis(2, at=seq(0,1,0.2), label=FALSE, tick=TRUE)
mtext(side=2, line=0.6, at=1, text="D", las=2, cex=2, font=2)

legend(x=10, y=0.50, legend=pretty.region[regions], lty=1, lwd=2, col=clrs[regions], cex=1.0)
```


### Figure 4

```{r, Figure_4, fig.width=7, fig.height=7}
par(mar=c(5, 5, 0.5, 1))
dotchart(gg, xlim=c(0,100), col="black", xlab="Unique reads that classified\nto genus or species level (%)", pch=19)

points(x=rdp[,"Mock"], y=25:30, pch=15, col="black")
points(x=rdp[,"Human"], y=17:22, pch=15, col="black")
points(x=rdp[,"Mouse"], y=9:14, pch=15, col="black")
points(x=rdp[,"Soil"], y=1:6, pch=15, col="black")

points(x=silva[,"Mock"], y=25:30, pch=17, col="black")
points(x=silva[,"Human"], y=17:22, pch=17, col="black")
points(x=silva[,"Mouse"], y=9:14, pch=17, col="black")
points(x=silva[,"Soil"], y=1:6, pch=17, col="black")

points(x=gg.sp[,"Mock"], y=25:30, pch=21, bg="gray")
points(x=gg.sp[,"Human"], y=17:22, pch=21, bg="gray")
points(x=gg.sp[,"Mouse"], y=9:14, pch=21, bg="gray")
points(x=gg.sp[,"Soil"], y=1:6, pch=21, bg="gray")

legend(x=63, y=12, legend=c("RDP (gen.)", "SILVA (gen.)", "greengenes (gen.+sp.)", "greengenes (sp.)"), pch=c(15, 17, 19, 21), col="black", pt.bg=c("black", "black", "black", "gray"), bg="white")
```



### Figure 5

```{r Figure_5, fig.width=7, fig.height=4}
x <- 0:20
e1 <- final.error["v19","unique.error"]
e2 <- 0.0025
e3 <- 0.0010
e4 <- 0.0002

par(mar=c(5,6,0.5, 0.5))
plot(x, dbinom(x, 1458, e1), type="l", ylim=c(0,0.35), xlab="Number of errors",
		 ylab="Full-length 16S rRNA\ngene sequences (%)", yaxt="n", lwd=3)
points(x, dbinom(x, 1458, e2), type="l", col="red", lwd=3)
points(x, dbinom(x, 1458, e3), type="l", col="blue", lwd=3)
points(x, dbinom(x, 1458, e4), type="l", col="darkgreen", lwd=3)
axis(2, at=seq(0,0.35,0.05), label=seq(0,35,5), las=1)
legend(x=12, y=0.30, legend=paste0(format(round(100*c(e1, e2, e3, e4), 2), nsmall=2), "%"),
			 lwd=3, col=c("black", "red", "blue", "darkgreen"))
```





```{r, versions}
sessionInfo()
```
